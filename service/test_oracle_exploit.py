#!/usr/bin/env python3
from Crypto.Cipher import AES
from Crypto import Random


_random_gen = Random.new()
_key = _random_gen.read(16)

def _remove_padding(data):
    pad_len = data[-1]
    if pad_len < 1 or pad_len > AES.block_size:
        return None
    for i in range(1, pad_len):
        if data[-i-1] != pad_len:
            return None
    return data[:-pad_len]

def _decrypt(data):
    iv = data[:AES.block_size]
    cipher = AES.new(_key, AES.MODE_CBC, iv)
    return _remove_padding(cipher.decrypt(data[AES.block_size:]))

def _add_padding(msg):
    pad_len = AES.block_size - (len(msg) % AES.block_size)
    padding = bytes([pad_len]) * pad_len
    return msg + padding
def encrypt(msg):
    iv = _random_gen.read(AES.block_size)
    cipher = AES.new(_key, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(_add_padding(msg))


def is_padding_ok(data):
    return _decrypt(data) is not None

def attack_message(msg):

    cipherfake=[0] * 16
    plaintext = [0] * 16
    current = 0
    message=""


    #I devide the list of bytes in blocks, and I put them in another list
    number_of_blocks = int(len(msg)/AES.block_size)
    blocks = [[]] * number_of_blocks
    for i in (range(number_of_blocks)):
        blocks[i] = msg[i * AES.block_size: (i + 1) * AES.block_size]

    for z in range(len(blocks)-1):  #for each message, I calculate the number of block
        for itera in range (1,17): #the length of each block is 16. I start by one because than I use its in a counter
            for v in range(256):
                cipherfake[-itera]=v
                if is_padding_ok(bytes(cipherfake)+blocks[z+1]): #the idea is that I put in 'is_padding_ok' the cipherfake(array of all 0) plus the last block
                                                                 #if the function return true I found the value
                    current=itera
                    plaintext[-itera]= v^itera^blocks[z][-itera]

            for w in range(1,current+1):
                cipherfake[-w] = plaintext[-w]^itera+1^blocks[z][-w] #for decode the second byte I must set the previous bytes with 'itera+1'


        for i in range(16):
            if plaintext[i] >= 32:
                char = chr(int(plaintext[i]))
                message += char

    #print("Crack: " + message + "\n")
    return str.encode(message)






def test_the_attack():

    messages = [b'Attack at dawn', ]
    for msg in messages:
        cracked_ct = attack_message(encrypt(msg))
        print('Testing:', msg)
        print('Cracked:',cracked_ct)
        
        assert cracked_ct == msg


if __name__ == '__main__':
    test_the_attack()